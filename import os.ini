import os
import torch
import numpy as np
from torch.utils.data import Dataset, DataLoader
from scipy.sparse import csr_matrix

class CoraDataset(Dataset):
    def __init__(self, root, split='train', transform=None, pre_transform=None):
        """
        Args:
            root (str): 数据集根目录（包含cora.content和cora.cites）
            split (str): 数据集划分（'train'/'val'/'test'）
            transform: 数据转换（可选）
            pre_transform: 预处理转换（可选）
        """
        self.root = root
        self.split = split
        self.transform = transform
        self.pre_transform = pre_transform
        
        # 加载数据
        self.load_data()
        
        # 划分数据集
        self.split_data()

    def load_data(self):
        # 1. 加载节点特征和标签（cora.content）
        content_path = os.path.join(self.root, 'cora.content')
        data = np.genfromtxt(content_path, dtype=str)
        
        # 提取节点ID、特征、标签
        self.node_ids = data[:, 0].astype(int)  # 节点ID
        self.features = csr_matrix(data[:, 1:-1].astype(float))  # 特征矩阵（稀疏矩阵）
        self.labels = data[:, -1]  # 标签（字符串）
        
        # 标签映射为整数
        self.label_to_idx = {label: i for i, label in enumerate(np.unique(self.labels))}
        self.labels = np.array([self.label_to_idx[label] for label in self.labels])
        
        # 节点ID映射为索引（0-based）
        self.node_id_to_idx = {node_id: i for i, node_id in enumerate(self.node_ids)}
        
        # 2. 加载边数据（cora.cites）
        cites_path = os.path.join(self.root, 'cora.cites')
        edges = np.genfromtxt(cites_path, dtype=int)
        self.edges = np.array([
            [self.node_id_to_idx[src], self.node_id_to_idx[dst]]  # 边转换为0-based索引
            for src, dst in edges
        ])

    def split_data(self):
        """划分训练/验证/测试集（按节点ID顺序，可根据需求修改）"""
        num_nodes = len(self.node_ids)
        indices = np.arange(num_nodes)
        np.random.seed(42)
        np.random.shuffle(indices)
        
        # 划分比例：60%训练，20%验证，20%测试
        train_size = int(0.6 * num_nodes)
        val_size = int(0.2 * num_nodes)
        
        if self.split == 'train':
            self.indices = indices[:train_size]
        elif self.split == 'val':
            self.indices = indices[train_size:train_size+val_size]
        elif self.split == 'test':
            self.indices = indices[train_size+val_size:]
        else:
            raise ValueError("split must be 'train', 'val', or 'test'")

    def __len__(self):
        return len(self.indices)

    def __getitem__(self, idx):
        """返回单个节点的特征和标签（图数据通常以整体处理，此处仅为示例）"""
        node_idx = self.indices[idx]
        feature = torch.tensor(self.features[node_idx].toarray()[0], dtype=torch.float32)
        label = torch.tensor(self.labels[node_idx], dtype=torch.long)
        return feature, label